From bbb7fa8cfaebab1e48e48b823f91565513e3280c Mon Sep 17 00:00:00 2001
From: Luca Weiss <luca@z3ntu.xyz>
Date: Sun, 15 Dec 2019 18:09:59 +0100
Subject: [PATCH 2/4] tg-hurdsig-global-dispositions.diff

---
 hurd/ctty-input.c                   |  16 +-
 hurd/ctty-output.c                  |  16 +-
 hurd/hurd/signal.h                  |  38 +++-
 hurd/hurdexec.c                     |   9 +-
 hurd/hurdmsg.c                      |  24 +--
 hurd/hurdsig.c                      | 272 +++++++++++++++++++++-------
 sysdeps/mach/hurd/fork.c            |  24 ++-
 sysdeps/mach/hurd/i386/sigreturn.c  |   9 +-
 sysdeps/mach/hurd/i386/trampoline.c |   6 +-
 sysdeps/mach/hurd/sigaction.c       |  16 +-
 sysdeps/mach/hurd/sigpending.c      |   6 +-
 sysdeps/mach/hurd/sigprocmask.c     |   8 +-
 sysdeps/mach/hurd/sigsuspend.c      |  15 +-
 sysdeps/mach/hurd/sigwait.c         |  21 ++-
 sysdeps/mach/hurd/spawni.c          |  25 +--
 15 files changed, 349 insertions(+), 156 deletions(-)

diff --git a/hurd/ctty-input.c b/hurd/ctty-input.c
index 95f067a16c..66b551aece 100644
--- a/hurd/ctty-input.c
+++ b/hurd/ctty-input.c
@@ -43,12 +43,15 @@ _hurd_ctty_input (io_t port, io_t ctty, error_t (*rpc) (io_t))
 	  else
 	    {
 	      struct hurd_sigstate *ss = _hurd_self_sigstate ();
-	      __spin_lock (&ss->lock);
+	      struct sigaction *actions;
+
+	      _hurd_sigstate_lock (ss);
+	      actions = _hurd_sigstate_actions (ss);
 	      if (__sigismember (&ss->blocked, SIGTTIN)
-		  || ss->actions[SIGTTIN].sa_handler == SIG_IGN)
+		  || actions[SIGTTIN].sa_handler == SIG_IGN)
 		/* We are blocking or ignoring SIGTTIN.  Just fail.  */
 		err = EIO;
-	      __spin_unlock (&ss->lock);
+	      _hurd_sigstate_unlock (ss);
 
 	      if (err == EBACKGROUND)
 		{
@@ -65,10 +68,11 @@ _hurd_ctty_input (io_t port, io_t ctty, error_t (*rpc) (io_t))
 		     SIGTTIN or resumed after being stopped.  Now this is
 		     still a "system call", so check to see if we should
 		  restart it.  */
-		  __spin_lock (&ss->lock);
-		  if (!(ss->actions[SIGTTIN].sa_flags & SA_RESTART))
+		  _hurd_sigstate_lock (ss);
+		  actions = _hurd_sigstate_actions (ss);
+		  if (!(actions[SIGTTIN].sa_flags & SA_RESTART))
 		    err = EINTR;
-		  __spin_unlock (&ss->lock);
+		  _hurd_sigstate_unlock (ss);
 		}
 	    }
 	}
diff --git a/hurd/ctty-output.c b/hurd/ctty-output.c
index d77c35ad6f..62f78d1ece 100644
--- a/hurd/ctty-output.c
+++ b/hurd/ctty-output.c
@@ -34,16 +34,19 @@ _hurd_ctty_output (io_t port, io_t ctty, error_t (*rpc) (io_t))
 
       do
 	{
+	  struct sigaction *actions;
+
 	  /* Don't use the ctty io port if we are blocking or ignoring
 	     SIGTTOU.  We redo this check at the top of the loop in case
 	     the signal handler changed the state.  */
-	  __spin_lock (&ss->lock);
+	  _hurd_sigstate_lock (ss);
+	  actions = _hurd_sigstate_actions (ss);
 	  if (__sigismember (&ss->blocked, SIGTTOU)
-	      || ss->actions[SIGTTOU].sa_handler == SIG_IGN)
+	      || actions[SIGTTOU].sa_handler == SIG_IGN)
 	    err = EIO;
 	  else
 	    err = 0;
-	  __spin_unlock (&ss->lock);
+	  _hurd_sigstate_unlock (ss);
 
 	  if (err)
 	    return (*rpc) (port);
@@ -70,10 +73,11 @@ _hurd_ctty_output (io_t port, io_t ctty, error_t (*rpc) (io_t))
 		     SIGTTOU or resumed after being stopped.  Now this is
 		     still a "system call", so check to see if we should
 		  restart it.  */
-		  __spin_lock (&ss->lock);
-		  if (!(ss->actions[SIGTTOU].sa_flags & SA_RESTART))
+		  _hurd_sigstate_lock (ss);
+		  actions = _hurd_sigstate_actions (ss);
+		  if (!(actions[SIGTTOU].sa_flags & SA_RESTART))
 		    err = EINTR;
-		  __spin_unlock (&ss->lock);
+		  _hurd_sigstate_unlock (ss);
 		}
 	    }
 	  /* If the last RPC generated a SIGTTOU, loop to try it again.  */
diff --git a/hurd/hurd/signal.h b/hurd/hurd/signal.h
index 3670a91a00..c48c0a04bf 100644
--- a/hurd/hurd/signal.h
+++ b/hurd/hurd/signal.h
@@ -73,7 +73,13 @@ struct hurd_sigstate
 
     sigset_t blocked;		/* What signals are blocked.  */
     sigset_t pending;		/* Pending signals, possibly blocked.  */
+
+    /* Signal handlers.  ACTIONS[0] is used to mark the threads with POSIX
+       semantics: if sa_handler is SIG_IGN instead of SIG_DFL, this thread
+       will receive global signals and use the process-wide action vector
+       instead of this one.  */
     struct sigaction actions[_NSIG];
+
     stack_t sigaltstack;
 
     /* Chain of thread-local signal preemptors; see <hurd/sigpreempt.h>.
@@ -129,6 +135,26 @@ extern struct hurd_sigstate *_hurd_self_sigstate (void)
 	by different threads.  */
      __attribute__ ((__const__));
 
+/* Process-wide signal state.  */
+
+extern struct hurd_sigstate *_hurd_global_sigstate;
+
+/* Mark the given thread as a process-wide signal receiver.  */
+
+extern void _hurd_sigstate_set_global_rcv (struct hurd_sigstate *ss);
+
+/* A thread can either use its own action vector and pending signal set
+   or use the global ones, depending on wether it has been marked as a
+   global receiver. The accessors below take that into account.  */
+
+extern void _hurd_sigstate_lock (struct hurd_sigstate *ss);
+extern struct sigaction *_hurd_sigstate_actions (struct hurd_sigstate *ss);
+extern sigset_t _hurd_sigstate_pending (const struct hurd_sigstate *ss);
+extern void _hurd_sigstate_unlock (struct hurd_sigstate *ss);
+
+/* Used by libpthread to remove stale sigstate structures.  */
+extern void _hurd_sigstate_delete (thread_t thread);
+
 #ifndef _HURD_SIGNAL_H_EXTERN_INLINE
 #define _HURD_SIGNAL_H_EXTERN_INLINE __extern_inline
 #endif
@@ -154,12 +180,6 @@ extern thread_t _hurd_msgport_thread;
 
 extern mach_port_t _hurd_msgport;
 
-
-/* Thread to receive process-global signals.  */
-
-extern thread_t _hurd_sigthread;
-
-
 /* Resource limit on core file size.  Enforced by hurdsig.c.  */
 extern int _hurd_core_limit;
 
@@ -227,10 +247,10 @@ _hurd_critical_section_unlock (void *our_lock)
       /* It was us who acquired the critical section lock.  Unlock it.  */
       struct hurd_sigstate *ss = (struct hurd_sigstate *) our_lock;
       sigset_t pending;
-      __spin_lock (&ss->lock);
+      _hurd_sigstate_lock (ss);
       __spin_unlock (&ss->critical_section_lock);
-      pending = ss->pending & ~ss->blocked;
-      __spin_unlock (&ss->lock);
+      pending = _hurd_sigstate_pending(ss) & ~ss->blocked;
+      _hurd_sigstate_unlock (ss);
       if (! __sigisemptyset (&pending))
 	/* There are unblocked signals pending, which weren't
 	   delivered because we were in the critical section.
diff --git a/hurd/hurdexec.c b/hurd/hurdexec.c
index 4e36d92f2e..21579626c1 100644
--- a/hurd/hurdexec.c
+++ b/hurd/hurdexec.c
@@ -126,12 +126,13 @@ _hurd_exec_paths (task_t task, file_t file,
   assert (! __spin_lock_locked (&ss->critical_section_lock));
   __spin_lock (&ss->critical_section_lock);
 
-  __spin_lock (&ss->lock);
+  _hurd_sigstate_lock (ss);
+  struct sigaction *actions = _hurd_sigstate_actions (ss);
   ints[INIT_SIGMASK] = ss->blocked;
-  ints[INIT_SIGPENDING] = ss->pending;
+  ints[INIT_SIGPENDING] = _hurd_sigstate_pending (ss);
   ints[INIT_SIGIGN] = 0;
   for (i = 1; i < NSIG; ++i)
-    if (ss->actions[i].sa_handler == SIG_IGN)
+    if (actions[i].sa_handler == SIG_IGN)
       ints[INIT_SIGIGN] |= __sigmask (i);
 
   /* We hold the sigstate lock until the exec has failed so that no signal
@@ -142,7 +143,7 @@ _hurd_exec_paths (task_t task, file_t file,
      critical section flag avoids anything we call trying to acquire the
      sigstate lock.  */
 
-  __spin_unlock (&ss->lock);
+  _hurd_sigstate_unlock (ss);
 
   /* Pack up the descriptor table to give the new program.  */
   __mutex_lock (&_hurd_dtable_lock);
diff --git a/hurd/hurdmsg.c b/hurd/hurdmsg.c
index 02b04f28ab..a480de7c90 100644
--- a/hurd/hurdmsg.c
+++ b/hurd/hurdmsg.c
@@ -121,17 +121,9 @@ get_int (int which, int *value)
     case INIT_UMASK:
       *value = _hurd_umask;
       return 0;
-    case INIT_SIGMASK:
-      {
-	struct hurd_sigstate *ss = _hurd_thread_sigstate (_hurd_sigthread);
-	__spin_lock (&ss->lock);
-	*value = ss->blocked;
-	__spin_unlock (&ss->lock);
-	return 0;
-      }
     case INIT_SIGPENDING:
       {
-	struct hurd_sigstate *ss = _hurd_thread_sigstate (_hurd_sigthread);
+	struct hurd_sigstate *ss = _hurd_global_sigstate;
 	__spin_lock (&ss->lock);
 	*value = ss->pending;
 	__spin_unlock (&ss->lock);
@@ -139,7 +131,7 @@ get_int (int which, int *value)
       }
     case INIT_SIGIGN:
       {
-	struct hurd_sigstate *ss = _hurd_thread_sigstate (_hurd_sigthread);
+	struct hurd_sigstate *ss = _hurd_global_sigstate;
 	sigset_t ign;
 	int sig;
 	__spin_lock (&ss->lock);
@@ -207,17 +199,9 @@ set_int (int which, int value)
       return 0;
 
       /* These are pretty odd things to do.  But you asked for it.  */
-    case INIT_SIGMASK:
-      {
-	struct hurd_sigstate *ss = _hurd_thread_sigstate (_hurd_sigthread);
-	__spin_lock (&ss->lock);
-	ss->blocked = value;
-	__spin_unlock (&ss->lock);
-	return 0;
-      }
     case INIT_SIGPENDING:
       {
-	struct hurd_sigstate *ss = _hurd_thread_sigstate (_hurd_sigthread);
+	struct hurd_sigstate *ss = _hurd_global_sigstate;
 	__spin_lock (&ss->lock);
 	ss->pending = value;
 	__spin_unlock (&ss->lock);
@@ -225,7 +209,7 @@ set_int (int which, int value)
       }
     case INIT_SIGIGN:
       {
-	struct hurd_sigstate *ss = _hurd_thread_sigstate (_hurd_sigthread);
+	struct hurd_sigstate *ss = _hurd_global_sigstate;
 	int sig;
 	const sigset_t ign = value;
 	__spin_lock (&ss->lock);
diff --git a/hurd/hurdsig.c b/hurd/hurdsig.c
index 5ac8c2a203..e31832d09c 100644
--- a/hurd/hurdsig.c
+++ b/hurd/hurdsig.c
@@ -46,9 +46,6 @@ mach_port_t _hurd_msgport;
 /* Thread listening on it.  */
 thread_t _hurd_msgport_thread;
 
-/* Thread which receives task-global signals.  */
-thread_t _hurd_sigthread;
-
 /* These are set up by _hurdsig_init.  */
 unsigned long int __hurd_sigthread_stack_base;
 unsigned long int __hurd_sigthread_stack_end;
@@ -56,6 +53,9 @@ unsigned long int __hurd_sigthread_stack_end;
 /* Linked-list of per-thread signal state.  */
 struct hurd_sigstate *_hurd_sigstates;
 
+/* Sigstate for the task-global signals.  */
+struct hurd_sigstate *_hurd_global_sigstate;
+
 /* Timeout for RPC's after interrupt_operation. */
 mach_msg_timeout_t _hurd_interrupted_rpc_timeout = 60000;
 
@@ -84,7 +84,7 @@ _hurd_thread_sigstate (thread_t thread)
     {
       ss = malloc (sizeof (*ss));
       if (ss == NULL)
-	__libc_fatal ("hurd: Can't allocate thread sigstate\n");
+	__libc_fatal ("hurd: Can't allocate sigstate\n");
       ss->thread = thread;
       __spin_lock_init (&ss->lock);
 
@@ -98,16 +98,19 @@ _hurd_thread_sigstate (thread_t thread)
       ss->intr_port = MACH_PORT_NULL;
       ss->context = NULL;
 
-      /* Initialize the sigaction vector from the default signal receiving
-	 thread's state, and its from the system defaults.  */
-      if (thread == _hurd_sigthread)
-	default_sigaction (ss->actions);
+      if (thread == MACH_PORT_NULL)
+	{
+	  /* Process-wide sigstate, use the system defaults.  */
+	  default_sigaction (ss->actions);
+
+	  /* The global sigstate is not added to the _hurd_sigstates list.
+	     It is created with _hurd_thread_sigstate (MACH_PORT_NULL)
+	     but should be accessed through _hurd_global_sigstate.  */
+	}
       else
 	{
-	  struct hurd_sigstate *s;
-	  for (s = _hurd_sigstates; s != NULL; s = s->next)
-	    if (s->thread == _hurd_sigthread)
-	      break;
+	  /* Use the global actions as a default for new threads.  */
+	  struct hurd_sigstate *s = _hurd_global_sigstate;
 	  if (s)
 	    {
 	      __spin_lock (&s->lock);
@@ -116,15 +119,109 @@ _hurd_thread_sigstate (thread_t thread)
 	    }
 	  else
 	    default_sigaction (ss->actions);
-	}
 
-      ss->next = _hurd_sigstates;
-      _hurd_sigstates = ss;
+	  ss->next = _hurd_sigstates;
+	  _hurd_sigstates = ss;
+	}
     }
   __mutex_unlock (&_hurd_siglock);
   return ss;
 }
 libc_hidden_def (_hurd_thread_sigstate)
+
+/* Destroy a sigstate structure.  Called by libpthread just before the
+ * corresponding thread is terminated (the kernel thread port must remain valid
+ * until this function is called.) */
+void
+_hurd_sigstate_delete (thread_t thread)
+{
+  struct hurd_sigstate **ssp, *ss;
+
+  __mutex_lock (&_hurd_siglock);
+  for (ssp = &_hurd_sigstates; *ssp; ssp = &(*ssp)->next)
+    if ((*ssp)->thread == thread)
+      break;
+
+  ss = *ssp;
+  if (ss)
+    *ssp = ss->next;
+
+  __mutex_unlock (&_hurd_siglock);
+  if (ss)
+    free (ss);
+}
+
+/* Make SS a global receiver, with pthread signal semantics.  */
+void
+_hurd_sigstate_set_global_rcv (struct hurd_sigstate *ss)
+{
+  assert (ss->thread != MACH_PORT_NULL);
+  ss->actions[0].sa_handler = SIG_IGN;
+}
+
+/* Check whether SS is a global receiver.  */
+static int
+sigstate_is_global_rcv (const struct hurd_sigstate *ss)
+{
+  return ss->actions[0].sa_handler == SIG_IGN;
+}
+
+/* Lock/unlock a hurd_sigstate structure.  If the accessors below require
+   it, the global sigstate will be locked as well.  */
+void
+_hurd_sigstate_lock (struct hurd_sigstate *ss)
+{
+  if (sigstate_is_global_rcv (ss))
+    __spin_lock (&_hurd_global_sigstate->lock);
+  __spin_lock (&ss->lock);
+}
+void
+_hurd_sigstate_unlock (struct hurd_sigstate *ss)
+{
+  __spin_unlock (&ss->lock);
+  if (sigstate_is_global_rcv (ss))
+    __spin_unlock (&_hurd_global_sigstate->lock);
+}
+
+/* Retreive a thread's full set of pending signals, including the global
+   ones if appropriate.  SS must be locked.  */
+sigset_t
+_hurd_sigstate_pending (const struct hurd_sigstate *ss)
+{
+  sigset_t pending = ss->pending;
+  if (sigstate_is_global_rcv (ss))
+    __sigorset (&pending, &pending, &_hurd_global_sigstate->pending);
+  return pending;
+}
+
+/* Clear a pending signal and return the associated detailed
+   signal information. SS must be locked, and must have signal SIGNO
+   pending, either directly or through the global sigstate.  */
+static struct hurd_signal_detail
+sigstate_clear_pending (struct hurd_sigstate *ss, int signo)
+{
+  if (sigstate_is_global_rcv (ss)
+      && __sigismember (&_hurd_global_sigstate->pending, signo))
+    {
+      __sigdelset (&_hurd_global_sigstate->pending, signo);
+      return _hurd_global_sigstate->pending_data[signo];
+    }
+
+  assert (__sigismember (&ss->pending, signo));
+  __sigdelset (&ss->pending, signo);
+  return ss->pending_data[signo];
+}
+
+/* Retreive a thread's action vector.  SS must be locked.  */
+struct sigaction *
+_hurd_sigstate_actions (struct hurd_sigstate *ss)
+{
+  if (sigstate_is_global_rcv (ss))
+    return _hurd_global_sigstate->actions;
+  else
+    return ss->actions;
+}
+
 
 /* Signal delivery itself is on this page.  */
 
@@ -219,6 +316,8 @@ static void
 abort_thread (struct hurd_sigstate *ss, struct machine_thread_all_state *state,
 	      void (*reply) (void))
 {
+  assert (ss->thread != MACH_PORT_NULL);
+
   if (!(state->set & THREAD_ABORTED))
     {
       error_t err = __thread_abort (ss->thread);
@@ -367,7 +466,7 @@ _hurdsig_abort_rpcs (struct hurd_sigstate *ss, int signo, int sigthread,
 	   call above will retry their RPCs unless we clear SS->intr_port.
 	   So we clear it for the thread taking a signal when SA_RESTART is
 	   clear, so that its call returns EINTR.  */
-	if (! signo || !(ss->actions[signo].sa_flags & SA_RESTART))
+	if (! signo || !(_hurd_sigstate_actions (ss) [signo].sa_flags & SA_RESTART))
 	  ss->intr_port = MACH_PORT_NULL;
       }
 
@@ -490,9 +589,11 @@ weak_alias (_hurdsig_preemptors, _hurdsig_preempters)
 		  | sigmask (SIGSTOP) | sigmask (SIGTSTP))
 
 /* Actual delivery of a single signal.  Called with SS unlocked.  When
-   the signal is delivered, return 1 with SS locked.  If the signal is
-   being traced, return 0 with SS unlocked.   */
-static int
+   the signal is delivered, return SS, locked (or, if SS was originally
+   _hurd_global_sigstate, the sigstate of the actual thread the signal
+   was delivered to).  If the signal is being traced, return NULL with
+   SS unlocked.   */
+static struct hurd_sigstate *
 post_signal (struct hurd_sigstate *ss,
 	     int signo, struct hurd_signal_detail *detail,
 	     int untraced, void (*reply) (void))
@@ -545,8 +646,12 @@ post_signal (struct hurd_sigstate *ss,
       assert_perror (err);
       for (i = 0; i < nthreads; ++i)
 	{
-	  if (threads[i] != _hurd_msgport_thread
-	      && (act != handle || threads[i] != ss->thread))
+	  if (act == handle && threads[i] == ss->thread)
+	    {
+	      /* The thread that will run the handler is kept suspended.  */
+	      ss_suspended = 1;
+	    }
+	  else if (threads[i] != _hurd_msgport_thread)
 	    {
 	      err = __thread_resume (threads[i]);
 	      assert_perror (err);
@@ -559,9 +664,6 @@ post_signal (struct hurd_sigstate *ss,
 		       (vm_address_t) threads,
 		       nthreads * sizeof *threads);
       _hurd_stopped = 0;
-      if (act == handle)
-	/* The thread that will run the handler is already suspended.  */
-	ss_suspended = 1;
     }
 
   error_t err;
@@ -577,13 +679,43 @@ post_signal (struct hurd_sigstate *ss,
 	}
 
       /* This call is just to check for pending signals.  */
-      __spin_lock (&ss->lock);
-      return 1;
+      _hurd_sigstate_lock (ss);
+      return ss;
     }
 
   thread_state.set = 0;		/* We know nothing.  */
 
-  __spin_lock (&ss->lock);
+  _hurd_sigstate_lock (ss);
+
+  /* If this is a global signal, try to find a thread ready to accept
+     it right away.  This is especially important for untraced signals,
+     since going through the global pending mask would de-untrace them.  */
+  if (ss->thread == MACH_PORT_NULL)
+  {
+    struct hurd_sigstate *rss;
+
+    __mutex_lock (&_hurd_siglock);
+    for (rss = _hurd_sigstates; rss != NULL; rss = rss->next)
+      {
+	if (! sigstate_is_global_rcv (rss))
+	  continue;
+
+	/* The global sigstate is already locked.  */
+	__spin_lock (&rss->lock);
+	if (! __sigismember (&rss->blocked, signo))
+	  {
+	    ss = rss;
+	    break;
+	  }
+	__spin_unlock (&rss->lock);
+      }
+    __mutex_unlock (&_hurd_siglock);
+  }
+
+  /* We want the preemptors to be able to update the blocking mask
+     without affecting the delivery of this signal, so we save the
+     current value to test against later.  */
+  sigset_t blocked = ss->blocked;
 
   /* Check for a preempted signal.  Preempted signals can arrive during
      critical sections.  */
@@ -641,12 +773,12 @@ post_signal (struct hurd_sigstate *ss,
 	    mark_pending ();
 	  else
 	    suspend ();
-	  __spin_unlock (&ss->lock);
+	  _hurd_sigstate_unlock (ss);
 	  reply ();
-	  return 0;
+	  return NULL;
 	}
 
-      handler = ss->actions[signo].sa_handler;
+      handler = _hurd_sigstate_actions (ss) [signo].sa_handler;
 
       if (handler == SIG_DFL)
 	/* Figure out the default action for this signal.  */
@@ -740,7 +872,7 @@ post_signal (struct hurd_sigstate *ss,
 
   /* Handle receipt of a blocked signal, or any signal while stopped.  */
   if (act != ignore		/* Signals ignored now are forgotten now.  */
-      && __sigismember (&ss->blocked, signo)
+      && __sigismember (&blocked, signo)
       || (signo != SIGKILL && _hurd_stopped))
     {
       mark_pending ();
@@ -776,6 +908,7 @@ post_signal (struct hurd_sigstate *ss,
 	 now's the time to set it going. */
       if (ss_suspended)
 	{
+	  assert (ss->thread != MACH_PORT_NULL);
 	  err = __thread_resume (ss->thread);
 	  assert_perror (err);
 	  ss_suspended = 0;
@@ -820,6 +953,8 @@ post_signal (struct hurd_sigstate *ss,
 	struct sigcontext *scp, ocontext;
 	int wait_for_reply, state_changed;
 
+	assert (ss->thread != MACH_PORT_NULL);
+
 	/* Stop the thread and abort its pending RPC operations.  */
 	if (! ss_suspended)
 	  {
@@ -956,23 +1091,25 @@ post_signal (struct hurd_sigstate *ss,
 	    }
 	}
 
+	struct sigaction *action = & _hurd_sigstate_actions (ss) [signo];
+
 	/* Backdoor extra argument to signal handler.  */
 	scp->sc_error = detail->error;
 
 	/* Block requested signals while running the handler.  */
 	scp->sc_mask = ss->blocked;
-	__sigorset (&ss->blocked, &ss->blocked, &ss->actions[signo].sa_mask);
+	__sigorset (&ss->blocked, &ss->blocked, &action->sa_mask);
 
 	/* Also block SIGNO unless we're asked not to.  */
-	if (! (ss->actions[signo].sa_flags & (SA_RESETHAND | SA_NODEFER)))
+	if (! (action->sa_flags & (SA_RESETHAND | SA_NODEFER)))
 	  __sigaddset (&ss->blocked, signo);
 
 	/* Reset to SIG_DFL if requested.  SIGILL and SIGTRAP cannot
            be automatically reset when delivered; the system silently
            enforces this restriction.  */
-	if (ss->actions[signo].sa_flags & SA_RESETHAND
+	if (action->sa_flags & SA_RESETHAND
 	    && signo != SIGILL && signo != SIGTRAP)
-	  ss->actions[signo].sa_handler = SIG_DFL;
+	  action->sa_handler = SIG_DFL;
 
 	/* Any sigsuspend call must return after the handler does.  */
 	wake_sigsuspend (ss);
@@ -990,7 +1127,7 @@ post_signal (struct hurd_sigstate *ss,
       }
     }
 
-  return 1;
+  return ss;
 }
 
 /* Return the set of pending signals in SS which should be delivered. */
@@ -1005,7 +1142,7 @@ pending_signals (struct hurd_sigstate *ss)
   if (_hurd_stopped || __spin_lock_locked (&ss->critical_section_lock))
     return 0;
 
-  return ss->pending & ~ss->blocked;
+  return _hurd_sigstate_pending (ss) & ~ss->blocked;
 }
 
 /* Post the specified pending signals in SS and return 1.  If one of
@@ -1017,12 +1154,15 @@ post_pending (struct hurd_sigstate *ss, sigset_t pending, void (*reply) (void))
   int signo;
   struct hurd_signal_detail detail;
 
+  /* Make sure SS corresponds to an actual thread, since we assume it won't
+     change in post_signal. */
+  assert (ss->thread != MACH_PORT_NULL);
+
   for (signo = 1; signo < NSIG; ++signo)
     if (__sigismember (&pending, signo))
       {
-	__sigdelset (&ss->pending, signo);
-	detail = ss->pending_data[signo];
-	__spin_unlock (&ss->lock);
+	detail = sigstate_clear_pending (ss, signo);
+	_hurd_sigstate_unlock (ss);
 
 	/* Will reacquire the lock, except if the signal is traced.  */
 	if (! post_signal (ss, signo, &detail, 0, reply))
@@ -1030,7 +1170,7 @@ post_pending (struct hurd_sigstate *ss, sigset_t pending, void (*reply) (void))
       }
 
   /* No more signals pending; SS->lock is still locked.  */
-  __spin_unlock (&ss->lock);
+  _hurd_sigstate_unlock (ss);
 
   return 1;
 }
@@ -1048,14 +1188,14 @@ post_all_pending_signals (void (*reply) (void))
       __mutex_lock (&_hurd_siglock);
       for (ss = _hurd_sigstates; ss != NULL; ss = ss->next)
         {
-	  __spin_lock (&ss->lock);
+	  _hurd_sigstate_lock (ss);
 
 	  pending = pending_signals (ss);
 	  if (pending)
 	    /* post_pending() below will unlock SS. */
 	    break;
 
-	  __spin_unlock (&ss->lock);
+	  _hurd_sigstate_unlock (ss);
 	}
       __mutex_unlock (&_hurd_siglock);
 
@@ -1088,11 +1228,12 @@ _hurd_internal_post_signal (struct hurd_sigstate *ss,
 	assert_perror (err);
     }
 
-  if (! post_signal (ss, signo, detail, untraced, reply))
+  ss = post_signal (ss, signo, detail, untraced, reply);
+  if (! ss)
     return;
 
   /* The signal was neither fatal nor traced.  We still hold SS->lock.  */
-  if (signo != 0)
+  if (signo != 0 && ss->thread != MACH_PORT_NULL)
     {
       /* The signal has either been ignored or is now being handled.  We can
 	 consider it delivered and reply to the killer.  */
@@ -1104,8 +1245,9 @@ _hurd_internal_post_signal (struct hurd_sigstate *ss,
     }
   else
     {
-      /* We need to check for pending signals for all threads.  */
-      __spin_unlock (&ss->lock);
+      /* If this was a process-wide signal or a poll request, we need
+	 to check for pending signals for all threads.  */
+      _hurd_sigstate_unlock (ss);
       if (! post_all_pending_signals (reply))
 	return;
 
@@ -1231,9 +1373,10 @@ _S_msg_sig_post (mach_port_t me,
   d.code = sigcode;
   d.exc = 0;
 
-  /* Post the signal to the designated signal-receiving thread.  This will
-     reply when the signal can be considered delivered.  */
-  _hurd_internal_post_signal (_hurd_thread_sigstate (_hurd_sigthread),
+  /* Post the signal to a global receiver thread (or mark it pending in
+     the global sigstate).  This will reply when the signal can be
+     considered delivered.  */
+  _hurd_internal_post_signal (_hurd_global_sigstate,
 			      signo, &d, reply_port, reply_port_type,
 			      0); /* Stop if traced.  */
 
@@ -1261,7 +1404,7 @@ _S_msg_sig_post_untraced (mach_port_t me,
 
   /* Post the signal to the designated signal-receiving thread.  This will
      reply when the signal can be considered delivered.  */
-  _hurd_internal_post_signal (_hurd_thread_sigstate (_hurd_sigthread),
+  _hurd_internal_post_signal (_hurd_global_sigstate,
 			      signo, &d, reply_port, reply_port_type,
 			      1); /* Untraced flag. */
 
@@ -1272,8 +1415,8 @@ extern void __mig_init (void *);
 
 #include <mach/task_special_ports.h>
 
-/* Initialize the message port and _hurd_sigthread and start the signal
-   thread.  */
+/* Initialize the message port, _hurd_global_sigstate, and start the
+   signal thread.  */
 
 void
 _hurdsig_init (const int *intarray, size_t intarraysize)
@@ -1296,27 +1439,34 @@ _hurdsig_init (const int *intarray, size_t intarraysize)
 				  MACH_MSG_TYPE_MAKE_SEND);
   assert_perror (err);
 
+  /* Initialize the global signal state.  */
+  _hurd_global_sigstate = _hurd_thread_sigstate (MACH_PORT_NULL);
+
+  /* We block all signals, and let actual threads pull them from the
+     pending mask.  */
+  __sigfillset(& _hurd_global_sigstate->blocked);
+
   /* Initialize the main thread's signal state.  */
   ss = _hurd_self_sigstate ();
 
-  /* Copy inherited values from our parent (or pre-exec process state)
-     into the signal settings of the main thread.  */
+  /* Mark it as a process-wide signal receiver.  Threads in this set use
+     the common action vector in _hurd_global_sigstate.  */
+  _hurd_sigstate_set_global_rcv (ss);
+
+  /* Copy inherited signal settings from our parent (or pre-exec process
+     state) */
   if (intarraysize > INIT_SIGMASK)
     ss->blocked = intarray[INIT_SIGMASK];
   if (intarraysize > INIT_SIGPENDING)
-    ss->pending = intarray[INIT_SIGPENDING];
+    _hurd_global_sigstate->pending = intarray[INIT_SIGPENDING];
   if (intarraysize > INIT_SIGIGN && intarray[INIT_SIGIGN] != 0)
     {
       int signo;
       for (signo = 1; signo < NSIG; ++signo)
 	if (intarray[INIT_SIGIGN] & __sigmask(signo))
-	  ss->actions[signo].sa_handler = SIG_IGN;
+	  _hurd_global_sigstate->actions[signo].sa_handler = SIG_IGN;
     }
 
-  /* Set the default thread to receive task-global signals
-     to this one, the main (first) user thread.  */
-  _hurd_sigthread = ss->thread;
-
   /* Start the signal thread listening on the message port.  */
 
 #pragma weak __cthread_fork
diff --git a/sysdeps/mach/hurd/fork.c b/sysdeps/mach/hurd/fork.c
index d0bf7642b8..cf51a9031d 100644
--- a/sysdeps/mach/hurd/fork.c
+++ b/sysdeps/mach/hurd/fork.c
@@ -445,6 +445,7 @@ __fork (void)
 					      thread,
 					      MACH_MSG_TYPE_COPY_SEND)))
 	LOSE;
+      /* XXX consumed? (_hurd_sigthread is no more) */
       if (thread_refs > 1
 	  && (err = __mach_port_mod_refs (newtask, ss->thread,
 					  MACH_PORT_RIGHT_SEND,
@@ -610,10 +611,6 @@ __fork (void)
       for (i = 0; i < _hurd_nports; ++i)
 	__spin_unlock (&_hurd_ports[i].lock);
 
-      /* We are one of the (exactly) two threads in this new task, we
-	 will take the task-global signals.  */
-      _hurd_sigthread = ss->thread;
-
       /* Claim our sigstate structure and unchain the rest: the
 	 threads existed in the parent task but don't exist in this
 	 task (the child process).  Delay freeing them until later
@@ -633,6 +630,25 @@ __fork (void)
       ss->next = NULL;
       _hurd_sigstates = ss;
       __mutex_unlock (&_hurd_siglock);
+      /* Earlier on, the global sigstate may have been tainted and now needs to
+         be reinitialized.  Nobody is interested in its present state anymore:
+         we're not, the signal thread will be restarted, and there are no other
+         threads.
+
+         We can't simply allocate a fresh global sigstate here, as
+         _hurd_thread_sigstate will call malloc and that will deadlock trying
+         to determine the current thread's sigstate.  */
+#if 0
+      _hurd_thread_sigstate_init (_hurd_global_sigstate, MACH_PORT_NULL);
+#else
+      /* Only reinitialize the lock -- otherwise we might have to do additional
+         setup as done in hurdsig.c:_hurdsig_init.  */
+      __spin_lock_init (&_hurd_global_sigstate->lock);
+#endif
+
+      /* We are one of the (exactly) two threads in this new task, we
+	 will take the task-global signals.  */
+      _hurd_sigstate_set_global_rcv (ss);
 
       /* Fetch our new process IDs from the proc server.  No need to
 	 refetch our pgrp; it is always inherited from the parent (so
diff --git a/sysdeps/mach/hurd/i386/sigreturn.c b/sysdeps/mach/hurd/i386/sigreturn.c
index a2bb6d0dfb..c35ca5888e 100644
--- a/sysdeps/mach/hurd/i386/sigreturn.c
+++ b/sysdeps/mach/hurd/i386/sigreturn.c
@@ -31,6 +31,7 @@ __sigreturn2 (int *usp)
 {
   struct hurd_sigstate *ss = _hurd_self_sigstate ();
   __spin_unlock (&ss->lock);
+  // FIXME original patch has _hurd_sigstate_unlock (ss); in a similar instance instead of spin_unlock
 
   sp = usp;
 #define A(line) asm volatile (#line)
@@ -68,7 +69,7 @@ __sigreturn (struct sigcontext *scp)
     }
 
   ss = _hurd_self_sigstate ();
-  __spin_lock (&ss->lock);
+  _hurd_sigstate_lock (ss);
 
   /* Remove the link on the `active resources' chain added by
      _hurd_setup_sighandler.  Its purpose was to make sure
@@ -80,19 +81,19 @@ __sigreturn (struct sigcontext *scp)
   ss->intr_port = scp->sc_intr_port;
 
   /* Check for pending signals that were blocked by the old set.  */
-  if (ss->pending & ~ss->blocked)
+  if (_hurd_sigstate_pending (ss) & ~ss->blocked)
     {
       /* There are pending signals that just became unblocked.  Wake up the
 	 signal thread to deliver them.  But first, squirrel away SCP where
 	 the signal thread will notice it if it runs another handler, and
 	 arrange to have us called over again in the new reality.  */
       ss->context = scp;
-      __spin_unlock (&ss->lock);
+      _hurd_sigstate_unlock (ss);
       __msg_sig_post (_hurd_msgport, 0, 0, __mach_task_self ());
       /* If a pending signal was handled, sig_post never returned.
 	 If it did return, the pending signal didn't run a handler;
 	 proceed as usual.  */
-      __spin_lock (&ss->lock);
+      _hurd_sigstate_lock (ss);
       ss->context = NULL;
     }
 
diff --git a/sysdeps/mach/hurd/i386/trampoline.c b/sysdeps/mach/hurd/i386/trampoline.c
index 0c5d5a194c..1659a735f0 100644
--- a/sysdeps/mach/hurd/i386/trampoline.c
+++ b/sysdeps/mach/hurd/i386/trampoline.c
@@ -93,7 +93,11 @@ _hurd_setup_sighandler (struct hurd_sigstate *ss, __sighandler_t handler,
      the SP on sigreturn.  */
     state->basic.uesp = state->basic.ecx;
 
-  if ((ss->actions[signo].sa_flags & SA_ONSTACK)
+  /* XXX what if handler != action->handler (for instance, if a signal
+   * preemptor took over) ? */
+  action = & _hurd_sigstate_actions (ss) [signo];
+
+  if ((action->sa_flags & SA_ONSTACK)
       && !(ss->sigaltstack.ss_flags & (SS_DISABLE|SS_ONSTACK)))
     {
       sigsp = ss->sigaltstack.ss_sp + ss->sigaltstack.ss_size;
diff --git a/sysdeps/mach/hurd/sigaction.c b/sysdeps/mach/hurd/sigaction.c
index 39ce9a1388..9498995277 100644
--- a/sysdeps/mach/hurd/sigaction.c
+++ b/sysdeps/mach/hurd/sigaction.c
@@ -46,15 +46,15 @@ __sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
   ss = _hurd_self_sigstate ();
 
   __spin_lock (&ss->critical_section_lock);
-  __spin_lock (&ss->lock);
-  old = ss->actions[sig];
+  _hurd_sigstate_lock (ss);
+  old = _hurd_sigstate_actions (ss) [sig];
   if (act != NULL)
-    ss->actions[sig] = a;
+    _hurd_sigstate_actions (ss) [sig] = a;
 
   if (act != NULL && sig == SIGCHLD
       && (a.sa_flags & SA_NOCLDSTOP) != (old.sa_flags & SA_NOCLDSTOP))
     {
-      __spin_unlock (&ss->lock);
+      _hurd_sigstate_unlock (ss);
 
       /* Inform the proc server whether or not it should send us SIGCHLD for
 	 stopped children.  We do this in a critical section so that no
@@ -62,8 +62,8 @@ __sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
       __USEPORT (PROC,
 		 __proc_mod_stopchild (port, !(a.sa_flags & SA_NOCLDSTOP)));
 
-      __spin_lock (&ss->lock);
-      pending = ss->pending & ~ss->blocked;
+      _hurd_sigstate_lock (ss);
+      pending = _hurd_sigstate_pending (ss) & ~ss->blocked;
     }
   else if (act != NULL && (a.sa_handler == SIG_IGN || a.sa_handler == SIG_DFL))
     /* We are changing to an action that might be to ignore SIG signals.
@@ -72,11 +72,11 @@ __sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
        back and then SIG is unblocked, the signal pending now should not
        arrive.  So wake up the signal thread to check the new state and do
        the right thing.  */
-    pending = ss->pending & __sigmask (sig);
+    pending = _hurd_sigstate_pending (ss) & __sigmask (sig);
   else
     pending = 0;
 
-  __spin_unlock (&ss->lock);
+  _hurd_sigstate_unlock (ss);
   __spin_unlock (&ss->critical_section_lock);
 
   if (pending)
diff --git a/sysdeps/mach/hurd/sigpending.c b/sysdeps/mach/hurd/sigpending.c
index 397d5ecd22..538a0237f4 100644
--- a/sysdeps/mach/hurd/sigpending.c
+++ b/sysdeps/mach/hurd/sigpending.c
@@ -36,9 +36,9 @@ sigpending (sigset_t *set)
     }
 
   ss = _hurd_self_sigstate ();
-  __spin_lock (&ss->lock);
-  pending = ss->pending;
-  __spin_unlock (&ss->lock);
+  _hurd_sigstate_lock (ss);
+  pending = _hurd_sigstate_pending (ss);
+  _hurd_sigstate_unlock (ss);
 
   *set = pending;
   return 0;
diff --git a/sysdeps/mach/hurd/sigprocmask.c b/sysdeps/mach/hurd/sigprocmask.c
index 240c4290df..73cd2dbc38 100644
--- a/sysdeps/mach/hurd/sigprocmask.c
+++ b/sysdeps/mach/hurd/sigprocmask.c
@@ -36,7 +36,7 @@ __sigprocmask (int how, const sigset_t *set, sigset_t *oset)
 
   ss = _hurd_self_sigstate ();
 
-  __spin_lock (&ss->lock);
+  _hurd_sigstate_lock (ss);
 
   old = ss->blocked;
 
@@ -57,7 +57,7 @@ __sigprocmask (int how, const sigset_t *set, sigset_t *oset)
 	  break;
 
 	default:
-	  __spin_unlock (&ss->lock);
+	  _hurd_sigstate_unlock (ss);
 	  errno = EINVAL;
 	  return -1;
 	}
@@ -65,9 +65,9 @@ __sigprocmask (int how, const sigset_t *set, sigset_t *oset)
       ss->blocked &= ~_SIG_CANT_MASK;
     }
 
-  pending = ss->pending & ~ss->blocked;
+  pending = _hurd_sigstate_pending (ss) & ~ss->blocked;
 
-  __spin_unlock (&ss->lock);
+  _hurd_sigstate_unlock (ss);
 
   if (oset != NULL)
     *oset = old;
diff --git a/sysdeps/mach/hurd/sigsuspend.c b/sysdeps/mach/hurd/sigsuspend.c
index 9551285a70..f4642b7702 100644
--- a/sysdeps/mach/hurd/sigsuspend.c
+++ b/sysdeps/mach/hurd/sigsuspend.c
@@ -40,7 +40,7 @@ __sigsuspend (const sigset_t *set)
 
   ss = _hurd_self_sigstate ();
 
-  __spin_lock (&ss->lock);
+  _hurd_sigstate_lock (ss);
 
   oldmask = ss->blocked;
   if (set != NULL)
@@ -48,11 +48,11 @@ __sigsuspend (const sigset_t *set)
     ss->blocked = newmask & ~_SIG_CANT_MASK;
 
   /* Notice if any pending signals just became unblocked.  */
-  pending = ss->pending & ~ss->blocked;
+  pending = _hurd_sigstate_pending (ss) & ~ss->blocked;
 
   /* Tell the signal thread to message us when a signal arrives.  */
   ss->suspended = wait;
-  __spin_unlock (&ss->lock);
+  _hurd_sigstate_unlock (ss);
 
   if (pending)
     /* Tell the signal thread to check for pending signals.  */
@@ -63,10 +63,11 @@ __sigsuspend (const sigset_t *set)
 	      MACH_MSG_TIMEOUT_NONE, MACH_PORT_NULL);
   __mach_port_destroy (__mach_task_self (), wait);
 
-  __spin_lock (&ss->lock);
-  ss->blocked = oldmask;	/* Restore the old mask.  */
-  pending = ss->pending & ~ss->blocked;	/* Again check for pending signals.  */
-  __spin_unlock (&ss->lock);
+  /* Restore the old mask and check for pending signals again.  */
+  _hurd_sigstate_lock (ss);
+  ss->blocked = oldmask;
+  pending = _hurd_sigstate_pending(ss) & ~ss->blocked;
+  _hurd_sigstate_unlock (ss);
 
   if (pending)
     /* Tell the signal thread to check for pending signals.  */
diff --git a/sysdeps/mach/hurd/sigwait.c b/sysdeps/mach/hurd/sigwait.c
index b70f7685b3..2594761245 100644
--- a/sysdeps/mach/hurd/sigwait.c
+++ b/sysdeps/mach/hurd/sigwait.c
@@ -27,7 +27,7 @@ int
 __sigwait (const sigset_t *set, int *sig)
 {
   struct hurd_sigstate *ss;
-  sigset_t mask, ready;
+  sigset_t mask, ready, blocked;
   int signo = 0;
   struct hurd_signal_preemptor preemptor;
   jmp_buf buf;
@@ -49,8 +49,8 @@ __sigwait (const sigset_t *set, int *sig)
       /* Make sure this is all kosher */
       assert (__sigismember (&mask, signo));
 
-      /* Make sure this signal is unblocked */
-      __sigdelset (&ss->blocked, signo);
+      /* Restore the blocking mask. */
+      ss->blocked = blocked;
 
       return pe->handler;
     }
@@ -71,10 +71,11 @@ __sigwait (const sigset_t *set, int *sig)
     __sigemptyset (&mask);
 
   ss = _hurd_self_sigstate ();
-  __spin_lock (&ss->lock);
+  _hurd_sigstate_lock (ss);
 
   /* See if one of these signals is currently pending.  */
-  __sigandset (&ready, &ss->pending, &mask);
+  sigset_t pending = _hurd_sigstate_pending (ss);
+  __sigandset (&ready, &pending, &mask);
   if (! __sigisemptyset (&ready))
     {
       for (signo = 1; signo < NSIG; signo++)
@@ -102,7 +103,11 @@ __sigwait (const sigset_t *set, int *sig)
       preemptor.next = ss->preemptors;
       ss->preemptors = &preemptor;
 
-      __spin_unlock (&ss->lock);
+      /* Unblock the expected signals */
+      blocked = ss->blocked;
+      ss->blocked &= ~mask;
+
+      _hurd_sigstate_unlock (ss);
 
       /* Wait. */
       __mach_msg (&msg, MACH_RCV_MSG, 0, sizeof (msg), wait,
@@ -113,7 +118,7 @@ __sigwait (const sigset_t *set, int *sig)
     {
       assert (signo);
 
-      __spin_lock (&ss->lock);
+      _hurd_sigstate_lock (ss);
 
       /* Delete our preemptor. */
       assert (ss->preemptors == &preemptor);
@@ -122,7 +127,7 @@ __sigwait (const sigset_t *set, int *sig)
 
 
 all_done:
-  spin_unlock (&ss->lock);
+  _hurd_sigstate_unlock (ss);
 
   __mach_port_destroy (__mach_task_self (), wait);
   *sig = signo;
diff --git a/sysdeps/mach/hurd/spawni.c b/sysdeps/mach/hurd/spawni.c
index e6b032b8a4..28a055f876 100644
--- a/sysdeps/mach/hurd/spawni.c
+++ b/sysdeps/mach/hurd/spawni.c
@@ -336,26 +336,29 @@ __spawni (pid_t *pid, const char *file,
   assert (! __spin_lock_locked (&ss->critical_section_lock));
   __spin_lock (&ss->critical_section_lock);
 
-  __spin_lock (&ss->lock);
+  _hurd_sigstate_lock (ss);
   ints[INIT_SIGMASK] = ss->blocked;
-  ints[INIT_SIGPENDING] = ss->pending;
+  ints[INIT_SIGPENDING] = _hurd_sigstate_pending (ss); /* XXX really? */
   ints[INIT_SIGIGN] = 0;
   /* Unless we were asked to reset all handlers to SIG_DFL,
      pass down the set of signals that were set to SIG_IGN.  */
-  if ((flags & POSIX_SPAWN_SETSIGDEF) == 0)
-    for (i = 1; i < NSIG; ++i)
-      if (ss->actions[i].sa_handler == SIG_IGN)
-	ints[INIT_SIGIGN] |= __sigmask (i);
-
-  /* We hold the sigstate lock until the exec has failed so that no signal
-     can arrive between when we pack the blocked and ignored signals, and
-     when the exec actually happens.  A signal handler could change what
+  {
+    struct sigaction *actions = _hurd_sigstate_actions (ss);
+    if ((flags & POSIX_SPAWN_SETSIGDEF) == 0)
+      for (i = 1; i < NSIG; ++i)
+	if (actions[i].sa_handler == SIG_IGN)
+	  ints[INIT_SIGIGN] |= __sigmask (i);
+  }
+
+  /* We hold the critical section lock until the exec has failed so that no
+     signal can arrive between when we pack the blocked and ignored signals,
+     and when the exec actually happens.  A signal handler could change what
      signals are blocked and ignored.  Either the change will be reflected
      in the exec, or the signal will never be delivered.  Setting the
      critical section flag avoids anything we call trying to acquire the
      sigstate lock.  */
 
-  __spin_unlock (&ss->lock);
+  _hurd_sigstate_unlock (ss);
 
   /* Set signal mask.  */
   if ((flags & POSIX_SPAWN_SETSIGMASK) != 0)
-- 
2.24.1

